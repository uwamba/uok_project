
    {% extends 'base.html' %}

    {% block title %}User Dashboard{% endblock %}
    
    {% block content %}
    <div class="section-top-border">
        <h3 class="mb-30">Test Count and details will be here</h3>
        <p><strong>Time Remaining:</strong> <span id="timer"></span></p>
        <div class="container mt-4">
            <h2>{{ test.name }}</h2>
<form method="post" id="test">
    {% csrf_token %}
    {% for question in questions %}
    <div class="mb-4">
        <h5>{{ question.text }}</h5>
        <h5>Type: {{ question.question_type }}</h5>
        {% if question.question_type == "multiple" %}
            <!-- Checkbox for multiple answers -->
            <div>
                {% for option in question.options.all %}
                    <div class="form-check">
                        <input class="form-check-input multiple-choice" 
                        type="checkbox" name="{{ question.id }}" 
                        id="option_{{ option.id }}" 
                        data-question-id="{{ question.id }}" 
                        data-max-selection="{{ question.max_selection }}"
                        value="{{ option.id }}" id="option_{{ option.id }}">
                        
                        <label class="form-check-label" for="{{ option.id }}">
                            {{ option.text }}
                        </label>
                    </div>
                {% endfor %}
            </div>
        {% elif question.question_type == "single" %}
            <!-- Radio button for single answer -->
            <div>
                {% for option in question.options.all %}
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="{{ question.id }}" value="{{ option.id }}" id="option_{{ option.id }}">
                        <label class="form-check-label" for="{{ option.id }}">
                            {{ option.text }}
                        </label>
                    </div>
                {% endfor %}
            </div>
        {% elif question.question_type == "text" %}
            <!-- Text box for text answer -->
            <div class="form-group">
                <textarea class="form-control" name="{{ question.id }}" rows="3" placeholder="Enter your answer here..."></textarea>
            </div>
        {% endif %}
    </div>
  
    {% endfor %}
    <button type="submit" class="genric-btn primary">Submit</button>
  </form>
  <button id="capture-screen" style="display:none;">Capture Screen</button>
  <!-- open vidu test code -->
  <div id="chat-container">
    <div id="chat-header">
        <h4>Chat with us</h4>
        <button id="close-chat" onclick="toggleChat()">X</button>
    </div>
    <div id="chat-body">
        <!-- Chat messages will appear here -->
        <div id="chat-messages"></div>
    </div>
    <div id="chat-input">
        <input type="text" id="message-input" placeholder="Type your message..." />
        <button onclick="sendMessage()">Send</button>
    </div>
</div>

<!-- Button to open the chat -->
<button id="open-chat" onclick="toggleChat()">Chat</button>
   
</div>
        </div>
    
        <!-- Modal -->
        <div class="modal fade" id="termsModal" tabindex="-1" aria-labelledby="termsModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="termsModalLabel">Terms and Conditions</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <p>By clicking "View Details", you agree to the test terms and conditions. Please ensure you adhere to all guidelines provided by the company.</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <a href="#" class="btn btn-primary" id="agreeButton">Agree</a>
                    </div>
                </div>
            </div>
        </div>
    
        <div id="video-container"></div>
    </div> 
    <div id="consent-modal">
        <div class="modal-content">
            <p>We need your consent to capture your screen. Please click "OK" to continue.</p>
            <button id="consent-ok">OK</button>
        </div>
    </div>
    {% load static %}
    <script src="{% static '/js/openvidu-browser-2.23.0.js' %}"></script>
    <script>
        // Get the remaining time from the context
        let mediaStream = null;
        let remainingTime = {{ remaining_time }};
    
        // Update the timer every second
        const timerElement = document.getElementById('timer');
        const form = document.getElementById('test');
        const interval = setInterval(() => {
            let minutes = Math.floor(remainingTime / 60);
            let seconds = remainingTime % 60;
    
            // Format the timer display
            timerElement.textContent = `${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
    
            if (remainingTime <= 0) {
                clearInterval(interval);
                alert('Time is up! Submitting the test...');
                form.submit(); // Automatically submit the form
            }
    
            remainingTime--;
        }, 1000);

         // Validate multiple-choice question max selection
    document.addEventListener('DOMContentLoaded', () => {
        const checkboxes = document.querySelectorAll('.multiple-choice');

        checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                const questionId = e.target.getAttribute('data-question-id');
                const maxSelections = parseInt(e.target.getAttribute('data-max-selection'), 10);

                const selected = document.querySelectorAll(
                    `.multiple-choice[data-question-id="${questionId}"]:checked`
                );

                if (selected.length > maxSelections) {
                    alert(`You can only select up to ${maxSelections} options for this question.`);
                    e.target.checked = false;
                }
            });
        });
    });
        //const videoElement = document.getElementById('videoElement');


        const userId = "{{ user.id|escapejs }}";
        const user = "{{ user.username|escapejs }}";
        const testId = "{{ test.id|escapejs }}";
        const sessionId="S000"+"{{ test.id|escapejs }}";
        console.log('generated username', user);
    
        // Access the user's webcam
       


const OV = new OpenVidu();
const session = OV.initSession();
console.log('-------------------------------- create toksession---------------------')
createSession(sessionId).then(response => {
    const sessionId = response; 
    console.log('response session Id:', sessionId); 
    console.log('-------------------------------- create session---------------------')
createToken(sessionId,user,userId,testId).then(response => {
		const token = response.token; // Extract the token string
		console.log('Extracted Token:', token); 
        //subscribe to stream

        session.on('streamCreated', (event) => {
            console.log('stream created hereeeeeeeeeeee:');
            const subscriber = session.subscribe(event.stream, undefined);
            subscriber.on('videoElementCreated', (videoEvent) => {
                addVideoToGrid(videoEvent.element);
                console.log('stream subscribbed hereeeeeeeeeeee:');
            });
        });

        // Handle participant leaving
        session.on('streamDestroyed', (event) => {
            const videoContainer = document.getElementById('video-container');
            const videoElement = document.querySelector(`video[src="${event.stream.streamId}"]`);
            if (videoElement) videoContainer.removeChild(videoElement);
        });

        //chat 
        // Handle chat messages
      session.on('signal:chat', event => {
        const message = event.data;
        const chatMessages = document.getElementById('chat-messages');
        const messageDiv = document.createElement('div');
        messageDiv.textContent = message;
        messageDiv.style.padding = '8px';
        messageDiv.style.marginBottom = '8px';
        messageDiv.style.backgroundColor = '#e0e0e0';
        messageDiv.style.borderRadius = '5px';
        chatMessages.appendChild(messageDiv);
       
        console.log("chat started hererrrrrrrrrrrr")
      });

    // Connect to the session
    session.connect(token, { username: user,userId:userId,testId:testId })
        .then(() => {
            // After connecting, publish your video stream
           
            navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                .then((stream) => {
                    console.log('Permissions granted');
                    
                    const publisher = OV.initPublisher('video-container', {
                        videoSource: undefined,  // Default webcam
                        audioSource: undefined,  // Default microphone
                        publishAudio: true,      // Publish audio (set to false to mute)
                        publishVideo: true,      // Publish video (set to false to hide video)
                        resolution: '640x480',   // Set video resolution
                        frameRate: 30,           // Set frame rate
                        mirror: false            // Disable mirror effect (useful for screen sharing)
                    });
                    
                    session.publish(publisher);
                    console.log(' session published');
                    publisher.on('videoElementCreated', (event) => {
                    console.error('event element', event.element);
                    addVideoToGrid(event.element);
            });
                })
                .catch((error) => {
                    console.error('Permissions denied:', error);
                });
           
        })
        .catch((error) => {
            console.error('Error connecting to the session:', error);
        });


    });
    
});


const SESSION_URL = 'http://localhost:4443/api/sessions';

async function createSession(sessionId) {
	console.log('SESSION ID IS:', sessionId);
	const csrftoken = getCSRFToken();
    try {
		const response = await fetch(`http://127.0.0.1:8000/video/create_session/`, {
            method: 'POST',
            headers: {
                'Authorization': 'Basic ' + btoa('OPENVIDUAPP:my_secret'),  // Replace with your actual OpenVidu secret
                'Content-Type': 'application/json',
                'X-CSRF-TOKEN': csrftoken,  // Include CSRF token if required by your backend
            },
            body: JSON.stringify({ customSessionId: sessionId }),

		});
        console.log('response at front end from crearing session',response );
        if (!response.ok) {

			if (response.status === 409) {
				// Session already exists
				const sessionData = await response.json();
				console.log('Session already exists:', sessionData.customSessionId);
				return sessionData.customSessionId;
				
			} else {
				// Other errors
				const errorDetails = await response.json().catch(() => null); // Handle cases where response isn't JSON
				throw new Error(
					`HTTP Error: ${response.status} ${response.statusText}\n` +
					`Details: ${JSON.stringify(errorDetails)}`
				);
			}

            // Parse error details if possible
            
        }else{
            const sessionData = await response.json();
			console.log('Session Created:', sessionData);
			return sessionData.sessionId;  
        }

    } catch (error) {
        console.error('Error creating session:', error.message || error);
    }
}
async function createToken(sessionId,username,userId,testId) {

    const csrftoken = getCSRFToken();  // Assuming you're using CSRF token protection, replace this if necessary

    console.log('Requesting token for sessionId:', sessionId);

    try {
        const response = await fetch(`http://127.0.0.1:8000/video/generate_token/${sessionId}/`, {
            method: 'POST',
            headers: {
                'Authorization': 'Basic ' + btoa('OPENVIDUAPP:my_secret'),  // Replace with your actual OpenVidu secret
                'Content-Type': 'application/json',
                'X-CSRF-TOKEN': csrftoken,  // Include CSRF token if required by your backend
            },
            body: JSON.stringify({ username: username, customSessionId: sessionId,userId: userId, testId: testId}), // Send the participant's username in the body
        });

        if (!response.ok) {
            throw new Error(`Request failed with status ${response.status}`);
        }

        const data = await response.json();  // Parse the JSON response
        return data;  // Return the response data (token)
    } catch (error) {
        console.error('Error occurred while fetching token:', error);
        throw error;  // Throw error for further handling if needed
    }
}



function getCSRFToken() {
	const name = 'csrftoken';
	const cookies = document.cookie.split(';');
	for (let cookie of cookies) {
		const [key, value] = cookie.trim().split('=');
		if (key === name) {
			return decodeURIComponent(value);
		}
	}
	return null;
}

function generateRandomString(length) {
    return Math.random().toString(36).substring(2, 2 + length);
}
function addVideoToGrid(videoElement) {
    const videoContainer = document.getElementById('video-container');
    videoContainer.appendChild(videoElement);
}

function addVideoToGrid(videoElement) {
    const videoContainer = document.getElementById('video-container');
    videoContainer.appendChild(videoElement);
    updateGridLayout();
}

        // Function to update the grid layout dynamically
function updateGridLayout() {
    const videoContainer = document.getElementById('video-container');
    const videos = videoContainer.children.length;
    videoContainer.style.gridTemplateColumns = `repeat(${Math.ceil(Math.sqrt(videos))}, 1fr)`;
}


function toggleChat() {
    const chatContainer = document.getElementById('chat-container');
    const openChatButton = document.getElementById('open-chat');
    
    if (chatContainer.style.display === 'none' || chatContainer.style.display === '') {
        chatContainer.style.display = 'flex';
        openChatButton.style.display = 'none'; // Hide open button when chat is open
    } else {
        chatContainer.style.display = 'none';
        openChatButton.style.display = 'block'; // Show open button when chat is closed
    }
}

// Send message and add it to the chat
function sendMessage() {
    const messageInput = document.getElementById('message-input');
    const chatMessages = document.getElementById('chat-messages');
    
    const messageText = messageInput.value.trim();

    if (messageText) {
        console.log('sart sending');
        console.log(session)
        console.log('sart sending');
        // Display the message locally
        const messageDiv = document.createElement('div');
        messageDiv.textContent = messageText;
        messageDiv.style.padding = '8px';
        messageDiv.style.marginBottom = '8px';
        messageDiv.style.backgroundColor = '#e0e0e0';
        messageDiv.style.borderRadius = '5px';
        chatMessages.appendChild(messageDiv);

        // Ensure session is connected before sending signal
        if (session) {
            console.error('Session sending chat message:');
            session.signal({
                type: 'chat',
                data: messageText,
            }).catch(error => {
                console.error('Error sending chat message:', error);
            });
        } else {
            console.warn('Session is not connected. Cannot send message.');
        }

        // Clear input field and scroll to bottom
        messageInput.value = '';
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
}

async function trackTabStatus() {
 const userId = "{{ userId|escapejs }}";
 const testId = "{{ test.id|escapejs }}";
 console.log('initial test id here',testId);
 //const screenshotDataURL =  await takeScreenShot();
  // Detect focus and blur (when the tab gets focus or loses focus)
  window.addEventListener('focus', function() {
    console.log('Tab is focused!');
  });

   window.addEventListener('blur', function() {
    console.log('Tab is blurred (inactive)!');
    //captureScreenshot(userId, testId, 'screenshot', 'user tab is inactive');
   
  });

  // Detect visibility change (when the tab becomes visible or hidden)
   document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
      console.log('Tab is hidden!');
      captureScreenshot(userId, testId, 'screenshot', 'user tab is hidden');
    } else {
      console.log('Tab is visible!');
    }
  });

  // Check if the tab is visible when the page loads
  if (document.hidden) {
    console.log('Tab is initially hidden!');
    //captureScreenshot(userId, testId, 'screenshot', 'user tab is hidden');
  } else {
    console.log('Tab is initially visible!');
    
  }
}


// Usage with .then() and .catch()


// Example usage:


async function sendMonitoringLog(userId, testId, activityType, activityData, screenshotDataURL) {
    const csrftoken = getCSRFToken(); 
    try {
   
       
        const response = await fetch('http://127.0.0.1:8000/video/upload-monitoring-log/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                user_id: userId,
                test_id: testId,
                activity_type: activityType,
                activityData: activityData, // Pass JSON data
                screenshot: screenshotDataURL,      // Base64-encoded image
            }),
        });

        if (response.ok) {
            const result = await response.json();
            if (session) {
            console.log('Session sending chat message:');
            session.signal({
                type: 'screenshot',
                data: result.log_id,
            }).catch(error => {
                console.error('Error sending chat message:', error);
            });
        } else {
            console.warn('Session is not connected. Cannot send message.');
        }
            console.log('Monitoring log created successfully:', result);
        } else {
            const error = await response.json();
            console.error('Error creating monitoring log:');
        }
    } catch (error) {
        console.error('Network error:', error);
    }
}


        function showConsentModal() {
            document.getElementById('consent-modal').style.display = 'flex';
        }
    

        // Function to handle user consent and trigger screen capture
        
       document.getElementById('consent-ok').addEventListener('click', function () {
            // Hide the modal once the user gives consent
            document.getElementById('consent-modal').style.display = 'none';

            // Proceed with screen capture
            startScreenCapture();
            console.log('start screen capute');
        });

        // Show the consent modal when the page loads
        window.onload = () => {
            showConsentModal();
        };


// Function to start screen capture
async function startScreenCapture() {
    try {
        mediaStream = await navigator.mediaDevices.getDisplayMedia({
            video: { mediaSource: "screen" },
        });
        console.log('Screen capture started');
        // Now you can call takeScreenShot function after this
    } catch (err) {
        console.error('Error accessing screen capture:', err);
    }
}

// Function to take screenshot from the captured media stream
async function takeScreenShot() {
    if (!mediaStream) {
        return null; // Or handle error appropriately
    }

    const video = document.createElement('video');
    video.srcObject = mediaStream;
    video.autoplay = true;
    document.body.appendChild(video);

    // Wait until the video element has loaded metadata
    await new Promise((resolve) => {
        video.onloadedmetadata = () => {
            resolve(); // Resolve when metadata is loaded
        };
    });

    // Check if the video has loaded and has dimensions
    if (video.videoWidth === 0 || video.videoHeight === 0) {
        console.error("Video dimensions are invalid.");
        return null; // Handle error gracefully
    }

    // Create a canvas to draw the video frame for screenshot
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    return new Promise((resolve, reject) => {
        // Wait until the video has enough data to draw the frame
        video.onloadeddata = () => {
            try {
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageDataURL = canvas.toDataURL("image/png");
                console.log("Screenshot captured successfully!");
                resolve(imageDataURL);  // Resolve the Promise with the image data URL
            } catch (error) {
                reject(error);  // Reject the Promise if there was an error
            }
        };

        video.onerror = (error) => {
            reject(error);  // Reject the Promise if the video failed to load
        };
    });
}

// Usage
async function captureScreenshot(userId, testId, type, data) {
    try {
        const screenshotData = await takeScreenShot(); // Then take the screenshot
        if (screenshotData) {
            console.log("Captured screenshot:", screenshotData);
            sendMonitoringLog(userId, testId, type, data, screenshotData) ;
        } else {
            console.log("No screenshot captured.");
        }
    } catch (error) {
        console.error("Error capturing screenshot:", error);
    }
}



trackTabStatus();

    </script>
    {% endblock %}
    
    
    